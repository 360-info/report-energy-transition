[
  {
    "objectID": "analysis/irena/index.html",
    "href": "analysis/irena/index.html",
    "title": "Analysis of IRENA electricity data",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(glue)\nlibrary(sf)\n\nLinking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(rgeoboundaries)\nlibrary(countrycode)\nlibrary(lwgeom)\n\nLinking to liblwgeom 3.0.0beta1 r16016, GEOS 3.10.2, PROJ 8.2.1\n\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nlibrary(here)\n\nhere() starts at /workspaces/report-energy-transition\n\n\nBefore we get started with the electricity data, let’s set up the spatial data we’re going to use to locate and name countries. First the names, using {countrycode}:\n\nname_subs &lt;- c(\n  \"FSM\" = \"Micronesia\",\n  \"XKX\" = \"Kosovo\")\nstandardise_countries &lt;- partial(countrycode, origin = \"iso3c\",\n    destination = c(\"country.name.en\", \"iso.name.en\"),\n    custom_match = name_subs)\n\nThen the country boundaries, using {rgeoboundaries}:\n\n# calculate country centroids (roughly - no spherical geometry b/c it's broken)\n# NOTE - rgeoboundaries will cache its downloads\nsf::sf_use_s2(FALSE)\n\nSpherical geometry (s2) switched off\n\ncountry_points &lt;-\n  geoboundaries() %&gt;%\n  st_centroid(of_largest_polygon = TRUE) %&gt;%\n  select(country = shapeName, iso = shapeGroup, geometry)\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n\nWarning in st_centroid.sfc(st_geometry(x), of_largest_polygon =\nof_largest_polygon): st_centroid does not give correct centroids for\nlongitude/latitude data\n\nmissing_points &lt;-\n  tribble(\n    ~ country,                                ~ iso, ~lat, ~ lon,\n    \"Greece\",                                 \"GRC\", 39.543080, 22.286516,\n    \"Aruba\",                                  \"ABW\", 12.505922, -69.975792,\n    \"Philippines\",                            \"PHL\", 11.651120, 123.347990,\n    \"American Samoa\",                         \"ASM\", -14.303205, -170.706638,\n    \"Anguilla\",                               \"AIA\", 18.216434, -63.047010,\n    \"Caribbean Netherlands\",                  \"BES\", 17.630239, -63.238425,\n    \"British Virgin Islands\",                 \"VGB\", 18.447914, -64.568766,\n    \"Cayman Islands\",                         \"CYM\", 19.482559, -80.524865,\n    \"Hong Kong\",                              \"HKG\", 22.390828, 114.148064,\n    \"Cook Islands\",                           \"COK\", -20.506062, -158.705700,\n    \"Curaçao\",                                \"CUW\", 12.191968, -68.998956,\n    \"Falkland Islands\",                       \"FLK\", -51.815445, -59.497967,\n    \"Faroe Islands\",                          \"FRO\", 62.060991, -6.931548,\n    \"French Guiana\",                          \"GUF\", 3.822285, -53.168343,\n    \"French Polynesia\",                       \"PYF\", -13.309305, -145.011540,\n    \"Guadeloupe\",                             \"GLP\", 16.211332, -61.451932,\n    \"Guam\",                                   \"GUM\", 13.427806, 144.777799,\n    \"Kosovo\",                                 \"XKX\", 42.534097, 20.847340,\n    \"Martinique\",                             \"MTQ\", 14.636397, -61.001410,\n    \"Mayotte\",                                \"MYT\", -12.831253, 45.153049,\n    \"Montserrat\",                             \"MSR\", 16.738979, -62.191919,\n    \"New Caledonia\",                          \"NCL\", -21.527411, 165.661714,\n    \"Niue\",                                   \"NIU\", -19.056664, -169.857740,\n    \"Puerto Rico\",                            \"PRI\", 18.201229, -66.464860,\n    \"St. Barthélemy\",                         \"BLM\", 17.896951, -62.830260,\n    \"Saint Martin (French part)\",             \"MAF\", 18.083456, -63.051166,\n    \"St. Pierre & Miquelon\",                  \"SPM\", 46.948623, -56.326391,\n    \"South Georgia & South Sandwich Islands\", \"SGS\", -56.602045, -31.574932,\n    \"Palestinian Territories\",                \"PSE\", 31.861835, 35.362214,\n    \"Switzerland\",                            \"CHE\", 46.803317, 8.437373,\n    \"Tokelau\",                                \"TKL\", -9.158506, -171.816830,\n    \"Turks & Caicos Islands\",                 \"TCA\", 21.802045, -71.874711,\n    \"U.S. Virgin Islands\",                    \"VIR\", 18.033734, -64.798169) %&gt;%\n  st_as_sf(coords = c(\"lon\", \"lat\"), dim = \"XY\") %&gt;%\n  st_set_crs(4326)\n\ncountry_points &lt;-\n  bind_rows(missing_points, country_points) |&gt;\n  distinct(iso, .keep_all = TRUE)\n\nThe original version of this analysis used data from IRENA’s Excel downloading tool, but it seems to be playing up. I’ve downloaded the data from IRENASTAT instead, but it’s slightly differently shaped (partly because installed capacity and generation are separate tables; partly because IRENASTAT has a 100k row export limit).\nThe tables used (which can be updated by downloading them from IRENASTAT and placing them in data as irena-src-[measure][grid_status].csv) are:\n\nInstalled electricity capacity by country/area (MW) by Country/area, Technology, Grid connection and Year\nElectricity generation (GWh) by Country/area, Technology, Grid connection and Year\n\n\nlist.files(here(\"data\"), full.names = TRUE,\n  pattern = glob2rx(\"irena-src-*.csv\")) %&gt;%\n  set_names(basename(.)) %&gt;%\n  map(read_csv, skip = 3,\n    col_names = c(\"country\", \"tech\", \"grid\", \"year\", \"value\"),\n    col_types = \"cccid\",\n    na = c(\"\", \"NA\", \"..\")) %&gt;%\n  bind_rows(.id = \"filename\") %&gt;%\n  separate(filename,\n    into = c(\"irena\", \"src\", \"measure\", \"grid\", \"ext\"), sep = \"[-.]\") %&gt;%\n  select(country, tech, measure, year, grid, value) -&gt;\nirena_bound\n\nThe IRENASTAT data, in this form, doesn’t classify technologies as renewable or non-renewable, so we’ll have to do that ourselves. We’ll also have to aggregate on- and off-grid values.\nI’ve used irena_bound %&gt;% pull(tech) %&gt;% unique() to check which technologies are in the data, and then compared those technologies against both OLD-irena-stats.csv (which did categorise them) and the dashboards on IRENA’s website to group most of the technologies.\nMost notably, nuclear does not appear to be considered renewable by IRENA.\n\nirena_bound %&gt;%\n  mutate(renewable_status = if_else(\n    tech %in% c(\n      \"Solar photovoltaic\",   \"Solar thermal energy\",\n      \"Onshore wind energy\",  \"Offshore wind energy\",\n      \"Renewable hydropower\", \"Mixed Hydro Plants\",\n      \"Pumped storage\",       \"Marine energy\",\n      \"Solid biofuels\",       \"Renewable municipal waste\",\n      \"Liquid biofuels\",      \"Biogas\",\n      \"Geothermal energy\"),\n    \"renewable\", \"nonrenewable\")) %&gt;%\n  group_by(country, measure, renewable_status, year) %&gt;%\n  summarise(total = sum(value, na.rm = TRUE)) %&gt;%\n  mutate(measure = recode(measure,\n    \"generation\" = \"totalgen_gwh\", \"capacity\" = \"totalcap_mw\")) %&gt;%\n  pivot_wider(\n    id_cols = c(country, year),\n    names_from = c(measure, renewable_status), names_sep = \"_\",\n    values_from = total) -&gt;\nirena_wide\n\n`summarise()` has grouped output by 'country', 'measure', 'renewable_status'.\nYou can override using the `.groups` argument.\n\n\nFinally, we also need ISO codes for the new data. I’m going to cheat here and steal them from OLD-irena-stats.csv for consistency’s sake.\n\nhere(\"data\", \"OLD-irena-stats.csv\") %&gt;%\n  read_csv(col_types = \"-cc-------\") %&gt;%\n  set_names(c(\"country\", \"iso\")) %&gt;%\n  distinct() %&gt;%\n  arrange(country) -&gt;\niso_map\n\n# a few country names have text encoding errors or have otherwise changed since\n# the last dataset. we'll patch their codes here\n# ({countrycodes} will standardise the names)\nirena_wide %&gt;%\n  left_join(iso_map, by = \"country\") %&gt;%\n  mutate(\n    iso = recode(country,\n      \"R�union\" = \"REU\",\n      \"T�rkiye\" = \"TUR\",\n      \"Saint Barth�lemy\" = \"BLM\",\n      \"C�te d'Ivoire\" = \"CIV\",\n      \"Cura�ao\" = \"CUW\",\n      \"Kosovo\" = \"XKX\",\n      \"China, Hong Kong Special Administrative Region\" = \"HKG\",\n      .default = iso)) %&gt;%\n  select(iso, everything()) -&gt;\nirena_joined  \n\n\n# widen by renewable status to calculate proportion of renewables\nirena_joined %&gt;%\n  mutate(\n    total_gen_gwh = totalgen_gwh_renewable + totalgen_gwh_nonrenewable,\n    total_cap_mw = totalcap_mw_renewable + totalcap_mw_nonrenewable,\n    renewprop_gen_gwh = totalgen_gwh_renewable / total_gen_gwh,\n    renewprop_cap_mw = totalcap_mw_renewable / total_cap_mw) %&gt;%\n  select(iso, country, year, starts_with(\"total\"), starts_with(\"renewprop\")) -&gt;\nproportions\n\nFinally, we’ll join the centroids and export to geoJSON.\n\n# first export a \"tall\" csv for deckgl...\nproportions %&gt;%\n  left_join(country_points, by = \"iso\", relationship = \"many-to-one\") %&gt;%\n  select(-starts_with(\"country\")) %&gt;%\n  mutate(\n    country = standardise_countries(iso),\n    point = st_coordinates(.$geometry),\n    lon = point[, \"X\"],\n    lat = point[, \"Y\"]) %&gt;%\n  select(iso, country, lon, lat, year, ends_with(\"gwh\"), ends_with(\"mw\")) %&gt;%\n  write_csv(here(\"data\", \"irena-totals.csv\"))\n\n# ... then a wide geojson for other map users\nproportions %&gt;%\n  pivot_wider(\n    names_from = year,\n    values_from = c(total_gen_gwh, total_cap_mw, renewprop_gen_gwh,\n      renewprop_cap_mw),\n    names_sep = \".\") %&gt;%\n  left_join(country_points, by = \"iso\") %&gt;%\n  select(-starts_with(\"country\")) %&gt;%\n  mutate(country = standardise_countries(iso)) %&gt;%\n  select(iso, country, everything()) %&gt;%\n  st_write(here(\"data\", \"irena-totals.geojson\"), delete_dsn = TRUE) -&gt;\ntotals_wide\n\nDeleting source `/workspaces/report-energy-transition/data/irena-totals.geojson' using driver `GeoJSON'\nWriting layer `irena-totals' to data source \n  `/workspaces/report-energy-transition/data/irena-totals.geojson' using driver `GeoJSON'\nWriting 4992 features with 98 fields and geometry type Point."
  },
  {
    "objectID": "analysis/ipcc/index.html",
    "href": "analysis/ipcc/index.html",
    "title": "Analysis of IPCC decarbonisation cost/potential data",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(here)\n\nhere() starts at /workspaces/report-energy-transition\n\n\n\nhere(\"data\", \"ipcc-decarbonisation-costs-unprocessed.csv\") |&gt;\n  read_csv() -&gt;\nsolutions\n\nRows: 144 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): category, item, cost_bucket\ndbl (1): potential_abatement_mtco2eq\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nLet’s work out the fraction of a solution’s potential each cost bucket represents.\nWe also want to do this for the uncertainty, but we want to be careful about not including the uncertainty in the bucket sums themselves, so let’s move the uncertainty to the end of each group.\nFinally, we’re going to rank the solutions within each cost bucket by their abatement potential. This will make positioning the bubbles easier in Observable Plot, as we don’t have another axis upon which to position the bubbles.\n\nsolutions |&gt;\n  mutate(is_uncertainty = cost_bucket == \"Uncertainty\") |&gt;\n  group_by(item) |&gt;\n  arrange(is_uncertainty) |&gt;\n  mutate(\n    potential_frac = potential_abatement_mtco2eq /\n      sum(head(potential_abatement_mtco2eq, -1))) |&gt;\n  group_by(cost_bucket) |&gt;\n  arrange(potential_abatement_mtco2eq) |&gt;\n  mutate(cost_bucket_potential_rank = 1:n()) -&gt;\nsolution_fracs\n\n\nsolution_fracs |&gt;\n  write_csv(here(\"data\", \"ipcc-decarbonisation-costs-processed.csv\"))"
  }
]