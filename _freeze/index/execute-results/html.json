{
  "hash": "5467f53f903e56b1a83c7c4c3aed3c8f",
  "result": {
    "markdown": "---\ntitle: \"Analysis of IRENA electricity data\"\nauthor: \"James Goldie, 360info\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(glue)\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to GEOS 3.10.2, GDAL 3.4.2, PROJ 8.2.1; sf_use_s2() is TRUE\n```\n:::\n\n```{.r .cell-code}\nlibrary(rgeoboundaries)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRegistered S3 method overwritten by 'hoardr':\n  method           from\n  print.cache_info httr\n```\n:::\n\n```{.r .cell-code}\nlibrary(countrycode)\nlibrary(lwgeom)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to liblwgeom 3.0.0beta1 r16016, GEOS 3.10.2, PROJ 8.2.1\n```\n:::\n\n```{.r .cell-code}\nlibrary(jsonlite)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n```\n:::\n\n```{.r .cell-code}\nlibrary(here)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/jgol0005/Code/reports/report-energy-transition\n```\n:::\n:::\n\n\nBefore we get started with the electricity data, let's set up the spatial data we're going to use to locate and name countries. First the names, using [`{countrycode}`](https://github.com/vincentarelbundock/countrycode):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname_subs <- c(\n  \"FSM\" = \"Micronesia\",\n  \"XKX\" = \"Kosovo\")\nstandardise_countries <- partial(countrycode, origin = \"iso3c\",\n    destination = c(\"country.name.en\", \"iso.name.en\"),\n    custom_match = name_subs)\n```\n:::\n\n\nThen the country boundaries, using [`{rgeoboundaries}`](https://github.com/wmgeolab/rgeoboundaries):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate country centroids (roughly - no spherical geometry b/c it's broken)\n# NOTE - rgeoboundaries will cache its downloads\nsf::sf_use_s2(FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSpherical geometry (s2) switched off\n```\n:::\n\n```{.r .cell-code}\ncountry_points <-\n  geoboundaries() %>%\n  st_centroid(of_largest_polygon = TRUE) %>%\n  select(country = shapeName, iso = shapeISO, geometry)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in st_centroid.sf(., of_largest_polygon = TRUE): st_centroid assumes\nattributes are constant over geometries of x\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in st_centroid.sfc(st_geometry(x), of_largest_polygon =\nof_largest_polygon): st_centroid does not give correct centroids for longitude/\nlatitude data\n```\n:::\n\n```{.r .cell-code}\nmissing_points <-\n  tribble(\n    ~ country,                                ~ iso, ~lat, ~ lon,\n    \"Greece\",                                 \"GRC\", 39.543080, 22.286516,\n    \"Aruba\",                                  \"ABW\", 12.505922, -69.975792,\n    \"Philippines\",                            \"PHL\", 11.651120, 123.347990,\n    \"American Samoa\",                         \"ASM\", -14.303205, -170.706638,\n    \"Anguilla\",                               \"AIA\", 18.216434, -63.047010,\n    \"Caribbean Netherlands\",                  \"BES\", 17.630239, -63.238425,\n    \"British Virgin Islands\",                 \"VGB\", 18.447914, -64.568766,\n    \"Cayman Islands\",                         \"CYM\", 19.482559, -80.524865,\n    \"Hong Kong\",                              \"HKG\", 22.390828, 114.148064,\n    \"Cook Islands\",                           \"COK\", -20.506062, -158.705700,\n    \"Curaçao\",                                \"CUW\", 12.191968, -68.998956,\n    \"Falkland Islands\",                       \"FLK\", -51.815445, -59.497967,\n    \"Faroe Islands\",                          \"FRO\", 62.060991, -6.931548,\n    \"French Guiana\",                          \"GUF\", 3.822285, -53.168343,\n    \"French Polynesia\",                       \"PYF\", -13.309305, -145.011540,\n    \"Guadeloupe\",                             \"GLP\", 16.211332, -61.451932,\n    \"Guam\",                                   \"GUM\", 13.427806, 144.777799,\n    \"Kosovo\",                                 \"XKX\", 42.534097, 20.847340,\n    \"Martinique\",                             \"MTQ\", 14.636397, -61.001410,\n    \"Mayotte\",                                \"MYT\", -12.831253, 45.153049,\n    \"Montserrat\",                             \"MSR\", 16.738979, -62.191919,\n    \"New Caledonia\",                          \"NCL\", -21.527411, 165.661714,\n    \"Niue\",                                   \"NIU\", -19.056664, -169.857740,\n    \"Puerto Rico\",                            \"PRI\", 18.201229, -66.464860,\n    \"St. Barthélemy\",                         \"BLM\", 17.896951, -62.830260,\n    \"Saint Martin (French part)\",             \"MAF\", 18.083456, -63.051166,\n    \"St. Pierre & Miquelon\",                  \"SPM\", 46.948623, -56.326391,\n    \"South Georgia & South Sandwich Islands\", \"SGS\", -56.602045, -31.574932,\n    \"Palestinian Territories\",                \"PSE\", 31.861835, 35.362214,\n    \"Switzerland\",                            \"CHE\", 46.803317, 8.437373,\n    \"Tokelau\",                                \"TKL\", -9.158506, -171.816830,\n    \"Turks & Caicos Islands\",                 \"TCA\", 21.802045, -71.874711,\n    \"U.S. Virgin Islands\",                    \"VIR\", 18.033734, -64.798169) %>%\n  st_as_sf(coords = c(\"lon\", \"lat\"), dim = \"XY\") %>%\n  st_set_crs(4326)\n\ncountry_points <- bind_rows(missing_points, country_points)\n```\n:::\n\n\nThe original version of this analysis used data from IRENA's Excel downloading tool, but it seems to be playing up. I've downloaded the data from [IRENASTAT](https://pxweb.irena.org/pxweb/en/IRENASTAT) instead, but it's slightly differently shaped (partly because installed capacity and generation are separate tables; partly because IRENASTAT has a 100k row export limit).\n\nThe tables used (which can be updated by downloading them from [IRENASTAT](https://pxweb.irena.org/pxweb/en/IRENASTAT) and placing them in `data` as `irena-src-[measure][grid_status].csv`) are:\n\n* Installed electricity capacity by country/area (MW) by Country/area, Technology, Grid connection and Year\n* Electricity generation (GWh) by Country/area, Technology, Grid connection and Year\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(here(\"data\"), full.names = TRUE,\n  pattern = glob2rx(\"irena-src-*.csv\")) %>%\n  set_names(basename(.)) %>%\n  map(read_csv, skip = 3,\n    col_names = c(\"country\", \"tech\", \"grid\", \"year\", \"value\"),\n    col_types = \"cccid\",\n    na = c(\"\", \"NA\", \"..\")) %>%\n  bind_rows(.id = \"filename\") %>%\n  separate(filename,\n    into = c(\"irena\", \"src\", \"measure\", \"grid\", \"ext\"), sep = \"[-.]\") %>%\n  select(country, tech, measure, year, grid, value) ->\nirena_bound\n```\n:::\n\n\nThe IRENASTAT data, in this form, doesn't classify technologies as renewable or non-renewable, so we'll have to do that ourselves. We'll also have to aggregate on- and off-grid values.\n\nI've used `irena_bound %>% pull(tech) %>% unique()` to check which technologies are in the data, and then compared those technologies against both `OLD-irena-stats.csv` (which _did_ categorise them) and the [dashboards on IRENA's website](https://www.irena.org/Data/View-data-by-topic/Capacity-and-Generation/Statistics-Time-Series) to group most of the technologies.\n\nMost notably, nuclear does not appear to be considered renewable by IRENA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nirena_bound %>%\n  mutate(renewable_status = if_else(\n    tech %in% c(\n      \"Solar photovoltaic\",   \"Solar thermal energy\",\n      \"Onshore wind energy\",  \"Offshore wind energy\",\n      \"Renewable hydropower\", \"Mixed Hydro Plants\",\n      \"Pumped storage\",       \"Marine energy\",\n      \"Solid biofuels\",       \"Renewable municipal waste\",\n      \"Liquid biofuels\",      \"Biogas\",\n      \"Geothermal energy\"),\n    \"renewable\", \"nonrenewable\")) %>%\n  group_by(country, measure, renewable_status, year) %>%\n  summarise(total = sum(value, na.rm = TRUE)) %>%\n  mutate(measure = recode(measure,\n    \"generation\" = \"totalgen_gwh\", \"capacity\" = \"totalcap_mw\")) %>%\n  pivot_wider(\n    id_cols = c(country, year),\n    names_from = c(measure, renewable_status), names_sep = \"_\",\n    values_from = total) ->\nirena_wide\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'country', 'measure', 'renewable_status'.\nYou can override using the `.groups` argument.\n```\n:::\n:::\n\n\nFinally, we also need ISO codes for the new data. I'm going to cheat here and steal them from `OLD-irena-stats.csv` for consistency's sake.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere(\"data\", \"OLD-irena-stats.csv\") %>%\n  read_csv(col_types = \"-cc-------\") %>%\n  set_names(c(\"country\", \"iso\")) %>%\n  distinct() %>%\n  arrange(country) ->\niso_map\n\n# a few country names have text encoding errors or have otherwise changed since\n# the last dataset. we'll patch their codes here\n# ({countrycodes} will standardise the names)\nirena_wide %>%\n  left_join(iso_map, by = \"country\") %>%\n  mutate(\n    iso = recode(country,\n      \"R�union\" = \"REU\",\n      \"T�rkiye\" = \"TUR\",\n      \"Saint Barth�lemy\" = \"BLM\",\n      \"C�te d'Ivoire\" = \"CIV\",\n      \"Cura�ao\" = \"CUW\",\n      \"Kosovo\" = \"XKX\",\n      \"China, Hong Kong Special Administrative Region\" = \"HKG\",\n      .default = iso)) %>%\n  select(iso, everything()) ->\nirena_joined  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# widen by renewable status to calculate proportion of renewables\nirena_joined %>%\n  mutate(\n    total_gen_gwh = totalgen_gwh_renewable + totalgen_gwh_nonrenewable,\n    total_cap_mw = totalcap_mw_renewable + totalcap_mw_nonrenewable,\n    renewprop_gen_gwh = totalgen_gwh_renewable / total_gen_gwh,\n    renewprop_cap_mw = totalcap_mw_renewable / total_cap_mw) %>%\n  select(iso, country, year, starts_with(\"total\"), starts_with(\"renewprop\")) ->\nproportions\n```\n:::\n\n\nFinally, we'll join the centroids and export to geoJSON.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first export a \"tall\" csv for deckgl...\nproportions %>%\n  left_join(country_points, by = \"iso\") %>%\n  select(-starts_with(\"country\")) %>%\n  mutate(\n    country = standardise_countries(iso),\n    point = st_coordinates(.$geometry),\n    lon = point[, \"X\"],\n    lat = point[, \"Y\"]) %>%\n  select(iso, country, lon, lat, year, ends_with(\"gwh\"), ends_with(\"mw\")) %>%\n  write_csv(here(\"data\", \"irena-totals.csv\"))\n\n# ... then a wide geojson for other map users\nproportions %>%\n  pivot_wider(\n    names_from = year,\n    values_from = c(total_gen_gwh, total_cap_mw, renewprop_gen_gwh,\n      renewprop_cap_mw),\n    names_sep = \".\") %>%\n  left_join(country_points, by = \"iso\") %>%\n  select(-starts_with(\"country\")) %>%\n  mutate(country = standardise_countries(iso)) %>%\n  select(iso, country, everything()) %>%\n  st_write(here(\"data\", \"irena-totals.geojson\"), delete_dsn = TRUE) ->\ntotals_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDeleting source `/Users/jgol0005/Code/reports/report-energy-transition/data/irena-totals.geojson' using driver `GeoJSON'\nWriting layer `irena-totals' to data source \n  `/Users/jgol0005/Code/reports/report-energy-transition/data/irena-totals.geojson' using driver `GeoJSON'\nWriting 4736 features with 94 fields and geometry type Point.\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}