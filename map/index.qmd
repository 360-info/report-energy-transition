---
title: 'TITLE HERE'
description: "Description here..."
page-layout: custom
theme: none
# this includes some default css for the titling, the bootstrap icons (since
# they only come with the bootstrap themes usually), and some extra css for the
# modals 
css:
  - /style/embed.css
  - https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.2/font/bootstrap-icons.css
  - /style/modal.css
  - https://cdn.jsdelivr.net/npm/maplibre-gl@2.1.9/dist/maplibre-gl.css
  - /style/map.css
execute:
  echo: false
resources:
  # - energy-transition-featuremedia.png
  - style.json
  - tiles/*
  - tiles/*/*/*.pbf
  - font/*
  - font/*/*
---

{{< include _popup-buttons.qmd >}}

```{ojs}
//| label: libraries

r = require.alias({
  maplibregl: "maplibre-gl@2.1.9/dist/maplibre-gl.js",
  h3: {},
  deck: "deck.gl@latest/dist.min.js"
});

maplibregl = r("maplibregl").catch(() => window["maplibregl"]);
deck = r("deck");
```


```{ojs}
//| label: inputs
//| classes: inputForm

// filterSummary = filteredTransferCount > 0 ?
//   html`<strong>${filteredTransferCount}</strong> transfers selected totalling at least <strong>$${filteredTransferSum > 1000 ? (filteredTransferSum / 1000).toFixed(1) + " billion" : filteredTransferSum + " million" }</strong> TIV` :
//   html`No transfers selected`;

// html`<a href="#" data-micromodal-trigger="modal-about" style="font-size:smaller"><i class="bi bi-info-circle-fill"></i> What is TIV?</a>`

// viewof selectedCountry = Inputs.text({ 
//   label: "Who",
//   placeholder: "Country or group name",
//   width: "100%" });

// i've added some extra css styling on this one by targeting
// .inputForm input[type="number"]
viewof selectedYear = Inputs.range([2000, 2021], {
  label: "Year",
  step: 1,
  value: 2020,
  width: "100%"
});

viewof selectedMeasure = Inputs.radio(
  new Map([
    ["Installed capacity (MW)", "cap_mw"],
    ["Energy generated this year (GWh)", "gen_gwh"],
  ]),
  {
    value: "cap_mw",
    label: "Measure"
  }
)

```

```{ojs}
//| label: bubble-layer
//| output: false

energyBubbles = new deck.MapboxLayer({
  id: "energyBubbles", 
  type: deck.ScatterplotLayer,
  data: [],
  getPosition: d => [Number(d.lon), Number(d.lat)],
  stroked: false,
  antialiasing: true,
  pickable: true,
  autoHighlight: true,
  highlightColor: [0, 0, 0, 64]
})
```

```{ojs}
//| label: define-popup
popup = new maplibregl.Popup({
  closeButton: false,
  closeOnClick: false
});
```

```{ojs}
//| label: map

/* this is a bit different to regular mapbox/maplibre instantiation
   it lets have the map react to other values in the document, like
   a button or a timer, without reinstantiating!
   (based on https://observablehq.com/@tmcw/using-mapbox-gl-js) */
   
viewof map = {
  let container = html`<div style="position: absolute; left: 0; top: 0; height: 100vh; width: 100%;" />`;

  // Give the container dimensions.
  yield container;

  // Create the \`map\` object with the mapboxgl.Map constructor, referencing
  // the container div
  let map = new maplibregl.Map({
    container,
    bounds: [[-175, -80], [175, 85]],
    // pitch: 30,
    antialias: true,
    style: "style.json"
  });

  // on map load:
  // - dispatch its value back to ojs
  // - add the deck.gl layer to the map
  // - add a prop to the layer that adds/removes a popup from the map
  //   (we can't do this on initial layer def because the map isn't ready yet)
  map.on("load", () => {
    container.value = map;
    container.dispatchEvent(new CustomEvent("input"));
    
    map.addLayer(energyBubbles);

    function updatePopup(info, event) {
      if (info && info.object) {

        const figureText = selectedMeasure == "cap_mw" ?
          ` had <strong>${info.object["total_" + selectedMeasure].toFixed(0)}&nbsp;MW</strong> of installed energy supply` :
          ` generated <strong>${info.object["total_" + selectedMeasure].toFixed(0)}&nbsp;GWh</strong> of energy`;


        popup
          .setLngLat(info.coordinate)
          .setHTML(
            `<span class="title">${info.object.country}</span>
            ${figureText} in ${info.object.year}.</br>
            <strong>${(info.object["renewprop_" + selectedMeasure] * 100).toFixed(1)}%</strong> of it was from renewable sources.`
            // `(to come)`
            )
          .addTo(map);
      } else {
        popup.remove();
      }
    }

    // attach our hover updater to the layer (can't do this until after the
    // layer is itself attached)
    energyBubbles.setProps({ onHover: updatePopup });

    // also configure the automatically-create deck instance
    energyBubbles.deck.setProps({ pickingRadius: 10 });
    
  });

}
```

```{ojs}
//| label: load-and-filter-data
//| output: false

// add a calculate field converting the iso code to a numeric, just so we have
// something to separate the circles on vertically
allData = FileAttachment("/data/irena-totals.csv")
  .csv({ typed: true })

// filter for (a) data matching the selected year and (b) present figures   
filteredData = allData
  .filter(d => d.year == Number(selectedYear))
  .filter(d => !isNaN(d["total_" + selectedMeasure]))
  .filter(d => !isNaN(d["renewprop_" + selectedMeasure]));

// filteredTransferCount =
//   filteredData.map(d => d.value).length;
// filteredTransferSum = {
//   const tivsToSum = filteredData.map(d => d.value);
//   if (tivsToSum.length > 0) {
//     return tivsToSum.reduce((x, y) => x + y);
//   } else {
//     return 0;
//   }
// }
  
```

```{ojs}
//| label: update-bubbles-and-scales
//| output: false

// color scale fn is a bit more complicated because we translate from d3's
// color format to deck.gl's
function divergingSolorScale(x) {

  const colorScale =
    d3.scaleDiverging()
    .domain([0, 0.5, 1])
    .interpolator(d3.interpolateRdBu)

  const obj = d3.color(colorScale(x))
  return [obj.r, obj.g, obj.b, 192]
}

// radius scaling is handled by d3 (range is metres, not pixels)
radiusScale = d3.scaleSqrt()
  .domain([0, d3.max(allData, d => d["total_" + selectedMeasure])])
  .range([10, 2000000])

// when the data updates, update the data passed to the map and the scale fns
energyBubbles.setProps({
  data: filteredData,
  getFillColor: d => divergingSolorScale(d["renewprop_" + selectedMeasure]),
  getRadius:    d => radiusScale(d["total_" + selectedMeasure])
});

```

<!-- share/about popups -->

{{< include _popup-dialogs.qmd >}}
